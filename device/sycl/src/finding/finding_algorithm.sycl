/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2023 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// DPL include(s).
// @NOTE: For GCC 9 or 10, onedpl header should come first
#include <oneapi/dpl/algorithm>
#include <oneapi/dpl/execution>

// Project include(s).
#include "../utils/get_queue.hpp"
#include "traccc/definitions/primitives.hpp"
#include "traccc/edm/device/finding_global_counter.hpp"
#include "traccc/finding/candidate_link.hpp"
#include "traccc/finding/device/apply_interaction.hpp"
#include "traccc/finding/device/build_tracks.hpp"
#include "traccc/finding/device/count_threads.hpp"
#include "traccc/finding/device/find_tracks.hpp"
#include "traccc/finding/device/make_barcode_sequence.hpp"
#include "traccc/finding/device/propagate_to_next_surface.hpp"
#include "traccc/sycl/finding/finding_algorithm.hpp"

// detray include(s).
#include "detray/core/detector.hpp"
#include "detray/detectors/telescope_metadata.hpp"
#include "detray/detectors/toy_metadata.hpp"
#include "detray/masks/unbounded.hpp"
#include "detray/propagator/navigator.hpp"
#include "detray/propagator/rk_stepper.hpp"

// VecMem include(s).
#include <vecmem/containers/data/vector_buffer.hpp>
#include <vecmem/containers/device_vector.hpp>
#include <vecmem/containers/jagged_device_vector.hpp>
#include <vecmem/containers/vector.hpp>

namespace traccc::sycl {

namespace kernels {
/// Class identifying the kernel running @c

/// traccc::device::make_barcode_sequence
class make_barcode_sequence;

template <typename detector_t>
class apply_interaction;

template <typename config_t>
class count_threads;

template <typename detector_t, typename config_t>
class find_tracks;

template <typename propagator_t, typename config_t>
class propagate_to_next_surface;

class build_tracks;

}  // namespace kernels

template <typename stepper_t, typename navigator_t>
finding_algorithm<stepper_t, navigator_t>::finding_algorithm(
    const config_type& cfg, const traccc::memory_resource& mr,
    queue_wrapper queue)
    : m_mr(mr), m_queue(queue), m_cfg(cfg) {

    // Initialize m_copy ptr based on memory resources that were given
    if (mr.host) {
        m_copy = std::make_unique<vecmem::sycl::copy>(queue.queue());
    } else {
        m_copy = std::make_unique<vecmem::copy>();
    }
};

template <typename stepper_t, typename navigator_t>
track_candidate_container_types::buffer
finding_algorithm<stepper_t, navigator_t>::operator()(
    const typename detector_type::detector_view_type& det_view,
    const vecmem::data::jagged_vector_view<
        typename navigator_t::intersection_type>& navigation_buffer,
    const measurement_collection_types::view& measurements,
    const bound_track_parameters_collection_types::buffer& seeds_buffer) const {

    // Copy setup
    m_copy->setup(seeds_buffer);
    m_copy->setup(navigation_buffer);

    // Prepare input parameters with seeds
    bound_track_parameters_collection_types::buffer in_params_buffer(
        m_copy->get_size(seeds_buffer), m_mr.main);
    bound_track_parameters_collection_types::device in_params(in_params_buffer);
    bound_track_parameters_collection_types::device seeds(seeds_buffer);

    /*
    oneapi::dpl::sort(oneapi::dpl::execution::dpcpp_default,
                      in_params.begin(), in_params.end());
    */
    // thrust::copy(thrust::device, seeds.begin(), seeds.end(),
    // in_params.begin());

    /*
    // Create a map for links
    std::map<unsigned int, vecmem::data::vector_buffer<candidate_link>>
        link_map;

    // Create a map for parameter ID to link ID
    std::map<unsigned int, vecmem::data::vector_buffer<unsigned int>>
        param_to_link_map;

    // Create a map for tip links
    std::map<unsigned int, vecmem::data::vector_buffer<
                               typename candidate_link::link_index_type>>
        tips_map;

    // Link size
    std::vector<std::size_t> n_candidates_per_step;
    n_candidates_per_step.reserve(m_cfg.max_track_candidates_per_track);

    std::vector<std::size_t> n_parameters_per_step;
    n_parameters_per_step.reserve(m_cfg.max_track_candidates_per_track);

    // Global counter object in Device memory
    vecmem::unique_alloc_ptr<device::finding_global_counter>
        global_counter_device =
            vecmem::make_unique_alloc<device::finding_global_counter>(
                m_mr.main);

    // Global counter object in Host memory
    device::finding_global_counter global_counter_host;
    */

    // Create track candidate buffer
    track_candidate_container_types::buffer track_candidates_buffer{
        {1, m_mr.main},
        {std::vector<std::size_t>(1, m_cfg.max_track_candidates_per_track),
         m_mr.main, m_mr.host, vecmem::data::buffer_type::resizable}};

    return track_candidates_buffer;
}

// Explicit template instantiation
using toy_detector_type =
    detray::detector<detray::toy_metadata<>, covfie::field_view,
                     detray::device_container_types>;
using toy_stepper_type = detray::rk_stepper<
    covfie::field<toy_detector_type::bfield_backend_type>::view_t, transform3,
    detray::constrained_step<>>;
using toy_navigator_type = detray::navigator<const toy_detector_type>;
template class finding_algorithm<toy_stepper_type, toy_navigator_type>;

using device_detector_type =
    detray::detector<detray::telescope_metadata<detray::rectangle2D<>>,
                     covfie::field_view, detray::device_container_types>;
using rk_stepper_type = detray::rk_stepper<
    covfie::field<device_detector_type::bfield_backend_type>::view_t,
    transform3, detray::constrained_step<>>;
using device_navigator_type = detray::navigator<const device_detector_type>;
template class finding_algorithm<rk_stepper_type, device_navigator_type>;

}  // namespace traccc::sycl
